<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ght_hash_table.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.12 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>ght_hash_table.h File Reference</h1>libghthash is a generic hash table used for storing arbitrary data. 
<a href="#_details">More...</a>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td colspan=2><br><h2>Data Structures</h2></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The hash table structure.</em> <a href="structght__hash__table__t.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><b>ght_iterator_t</b></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><b>s_hash_entry</b></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structs__hash__key.html">s_hash_key</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The structure for hash keys.</em> <a href="structs__hash__key.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td nowrap align=right valign=top>typedef unsigned int&nbsp;</td><td valign=bottom><a class="el" href="ght__hash__table_8h.html#a6">ght_uint32_t</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>unsigned 32 bit integer.</em> <a href="#a6">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>typedef <a class="el" href="structs__hash__key.html">s_hash_key</a>&nbsp;</td><td valign=bottom><a class="el" href="ght__hash__table_8h.html#a7">ght_hash_key_t</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The structure for hash keys.</em> <a href="#a7">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>typedef <a class="el" href="ght__hash__table_8h.html#a6">ght_uint32_t</a>(*&nbsp;</td><td valign=bottom><a class="el" href="ght__hash__table_8h.html#a9">ght_fn_hash_t</a> )(<a class="el" href="ght__hash__table_8h.html#a7">ght_hash_key_t</a> *p_key)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Definition of the hash function pointers.</em> <a href="#a9">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td><td valign=bottom><a class="el" href="ght__hash__table_8h.html#a10">ght_create</a> (unsigned int i_size, <a class="el" href="ght__hash__table_8h.html#a9">ght_fn_hash_t</a> fn_hash, int i_flags)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a new hash table.</em> <a href="#a10">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="ght__hash__table_8h.html#a11">ght_insert</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, void *p_entry_data, unsigned int i_key_size, void *p_key_data)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Insert an entry into the hash table.</em> <a href="#a11">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void *&nbsp;</td><td valign=bottom><a class="el" href="ght__hash__table_8h.html#a12">ght_get</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, unsigned int i_key_size, void *p_key_data)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Lookup an entry in the hash table.</em> <a href="#a12">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void *&nbsp;</td><td valign=bottom><a class="el" href="ght__hash__table_8h.html#a13">ght_remove</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, unsigned int i_key_size, void *p_key_data)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Remove an entry from the hash table.</em> <a href="#a13">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void *&nbsp;</td><td valign=bottom><a class="el" href="ght__hash__table_8h.html#a14">ght_first</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, ght_iterator_t *p_iterator)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return the first entry in the hash table.</em> <a href="#a14">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void *&nbsp;</td><td valign=bottom><a class="el" href="ght__hash__table_8h.html#a15">ght_next</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, ght_iterator_t *p_iterator)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return the next entry in the hash table.</em> <a href="#a15">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ght__hash__table_8h.html#a16">ght_rehash</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, unsigned int i_size)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Rehash the hash table.</em> <a href="#a16">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="ght__hash__table_8h.html#a17">ght_finalize</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Free the hash table.</em> <a href="#a17">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="ght__hash__table_8h.html#a6">ght_uint32_t</a>&nbsp;</td><td valign=bottom><a class="el" href="ght__hash__table_8h.html#a18">ght_one_at_a_time_hash</a> (<a class="el" href="ght__hash__table_8h.html#a7">ght_hash_key_t</a> *p_key)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>One-at-a-time-hash.</em> <a href="#a18">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="ght__hash__table_8h.html#a6">ght_uint32_t</a>&nbsp;</td><td valign=bottom><a class="el" href="ght__hash__table_8h.html#a19">ght_rotating_hash</a> (<a class="el" href="ght__hash__table_8h.html#a7">ght_hash_key_t</a> *p_key)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Rotating hash.</em> <a href="#a19">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="ght__hash__table_8h.html#a6">ght_uint32_t</a>&nbsp;</td><td valign=bottom><a class="el" href="ght__hash__table_8h.html#a20">ght_crc_hash</a> (<a class="el" href="ght__hash__table_8h.html#a7">ght_hash_key_t</a> *p_key)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>CRC32 hash.</em> <a href="#a20">More...</a><em></em></font><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
libghthash is a generic hash table used for storing arbitrary data.
<p>
 Libghthash really stores pointers to data - the hash table knows nothing about the actual type of the data.
<p>
A simple example to get started can be found in the <code>simple.c</code> file found in the distribution. <code>hash_test.c</code> provides a more comlpete example.
<p>
The MK2 version of the library should be more simple to use with fewer exported function calls and fewer structs. The usage have changed a bit since the first version though:
<p>
Some basic properties of the hash table are:
<p>
<ul>
<li>Both the data stored and the keys are of void type, which means that you can store any kind of data.</ul>
<ul>
<li>The only functions you probably will need to start is:<ul>
<li><a class="el" href="ght__hash__table_8h.html#a10">ght_create</a>(), which creates a new hash table<li><a class="el" href="ght__hash__table_8h.html#a11">ght_insert</a>(), which inserts a new entry into a table<li><a class="el" href="ght__hash__table_8h.html#a12">ght_get</a>(), which searches for an entry<li><a class="el" href="ght__hash__table_8h.html#a13">ght_remove</a>(), which removes and entry.</ul>
</ul>
<ul>
<li>Inserting entries is done without first creating a key, i.e. you insert with the data, the datasize, the key and the key size directly.</ul>
<ul>
<li>The hash table copies the key data when inserting new entries. This means that you don't have to malloc() the key before inserting a new entry.</ul>
<hr><h2>Typedef Documentation</h2>
<a name="a9" doxytag="ght_hash_table.h::ght_fn_hash_t"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="ght__hash__table_8h.html#a6">ght_uint32_t</a>(* ght_fn_hash_t)(<a class="el" href="ght__hash__table_8h.html#a7">ght_hash_key_t</a> *p_key)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Definition of the hash function pointers.
<p>
ght_fn_hash_t should be used when implementing new hash functions. Look at the supplied hash functions, like <a class="el" href="ght__hash__table_8h.html#a18">ght_one_at_a_time_hash</a>(), for examples of hash functions.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>p_key</em>&nbsp;</td><td>
the key to calculate the hash value for.</td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
a 32 bit hash value.</dl><dl compact><dt><b>
See also: </b><dd>
<a class="el" href="ght__hash__table_8h.html#a18">ght_one_at_a_time_hash</a>(), <a class="el" href="ght__hash__table_8h.html#a19">ght_rotating_hash</a>(), <a class="el" href="ght__hash__table_8h.html#a20">ght_crc_hash</a>() </dl>    </td>
  </tr>
</table>
<a name="a7" doxytag="ght_hash_table.h::ght_hash_key_t"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="structs__hash__key.html">s_hash_key</a>  ght_hash_key_t
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The structure for hash keys.
<p>
You should not care about this structure unless you plan to write your own hash functions.     </td>
  </tr>
</table>
<a name="a6" doxytag="ght_hash_table.h::ght_uint32_t"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef unsigned int ght_uint32_t
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
unsigned 32 bit integer.
<p>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a20" doxytag="ght_hash_table.h::ght_crc_hash"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="ght__hash__table_8h.html#a6">ght_uint32_t</a> ght_crc_hash </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="ght__hash__table_8h.html#a7">ght_hash_key_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>p_key</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
CRC32 hash.
<p>
CRC32 hash is a good hash function. This came from Dru Lemley &lt;<a href="mailto:spambait@lemley.net">spambait@lemley.net</a>&gt;.
<p>
<dl compact><dt><b>
Warning: </b><dd>
Don't call this function directly, it is only meant to be used as a callback for the hash table.</dl><dl compact><dt><b>
See also: </b><dd>
<a class="el" href="ght__hash__table_8h.html#a9">ght_fn_hash_t</a> , <a class="el" href="ght__hash__table_8h.html#a18">ght_one_at_a_time_hash</a>(), <a class="el" href="ght__hash__table_8h.html#a19">ght_rotating_hash</a>() </dl>    </td>
  </tr>
</table>
<a name="a10" doxytag="ght_hash_table.h::ght_create"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a>* ght_create </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>i_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="ght__hash__table_8h.html#a9">ght_fn_hash_t</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>fn_hash</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>i_flags</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new hash table.
<p>
The number of buckets should be about as big as the number of elements you wish to store in the table for good performance. The number of buckets is rounded to the next higher power of two.
<p>
The possible flags are:
<p>
<ul>
<li><code>GHT_HEURISTICS_TRANSPOSE</code>: Use transposing heuristics. An accessed element will move one step up in the bucket-list with this method. Cannot be combined with GHT_HEURISTICS_MOVE_TO_FRONT.<li><code>GHT_HEURISTICS_MOVE_TO_FRONT</code>: Use move-to-front heuristics. An accessed element will be moved the front of the bucket list with this method. Cannot be combined with GHT_HEURISTICS_TRANSPOSE.<li><code>GHT_AUTOMATIC_REHASH</code>: Perform automatic rehashing when the number of elements in the table are twice as many as the number of buckets. You should note that automatic rehashing will cause your application to be really slow when the table is rehashing (which might happen at times when you need speed), you should * therefore be careful with this in time-constrainted applications.</ul>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>i_size</em>&nbsp;</td><td>
the number of buckets in the hash table. Giving a non-power of two here will round the size up to the next power of two. </td></tr>
<tr><td valign=top><em>fn_hash</em>&nbsp;</td><td>
the hash function to use (NULL for default). You can define own hash functions to use here, see the implementation of <a class="el" href="ght__hash__table_8h.html#a18">ght_one_at_a_time_hash</a>() in <code>hash_table.c</code> for an example. </td></tr>
<tr><td valign=top><em>i_flags</em>&nbsp;</td><td>
specify the flags to use. This should be bitwise or:ed. note that some options are mutually exclusive.</td></tr>
</table>
</dl><dl compact><dt><b>
See also: </b><dd>
<a class="el" href="ght__hash__table_8h.html#a18">ght_one_at_a_time_hash</a>(), <a class="el" href="ght__hash__table_8h.html#a19">ght_rotating_hash</a>(), <a class="el" href="ght__hash__table_8h.html#a20">ght_crc_hash</a>()</dl><dl compact><dt><b>
Returns: </b><dd>
a pointer to the hash table or NULL upon error. </dl>    </td>
  </tr>
</table>
<a name="a17" doxytag="ght_hash_table.h::ght_finalize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ght_finalize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>p_ht</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free the hash table.
<p>
<a class="el" href="ght__hash__table_8h.html#a17">ght_finalize</a>() should typically be called at the end of the program. Note that only the metadata and the keys of the table is freed, not the entries. If you want to free the entries when removing the table, the entries will have to be manually freed before <a class="el" href="ght__hash__table_8h.html#a17">ght_finalize</a>() is called like:
<p>
<pre>
 ght_iterator_t iterator;
 void *p_e;

 for(p_e = ght_first(p_table, &amp;iterator); p_e; p_e = ght_next(p_table, &amp;iterator))
   {
     free(p_e);
   }

 ght_finalize(p_table);
 </pre><dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>p_ht</em>&nbsp;</td><td>
the table to remove. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a14" doxytag="ght_hash_table.h::ght_first"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* ght_first </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>ght_iterator_t *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p_iterator</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the first entry in the hash table.
<p>
This function should be used for iteration and is used together with <a class="el" href="ght__hash__table_8h.html#a15">ght_next</a>(). Note that you cannot assume anything about the order in which the entries are accessed. If an entry is inserted during an iteration, the entry might or might not occur in the iteration.
<p>
The use of the ght_iterator_t allows for several concurrent iterations, where you would use one ght_iterator_t for each iteration. In threaded environments, you should still lock access to the hash table for insertion and removal.
<p>
A typical example might look as follows: <pre>
 <a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_table;
 ght_iterator_t iterator;
 void *p_e;

 [Create table etc...]
 for(p_e = ght_first(p_table, &amp;iterator); p_e; p_e = ght_next(p_table, &amp;iterator))
   {
      [Do something with the current entry p_e]
   }
 </pre><dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>p_ht</em>&nbsp;</td><td>
the hash table to iterate through.</td></tr>
<tr><td valign=top><em>p_iterator</em>&nbsp;</td><td>
the iterator to use. The value of the structure is filled in by this function and may be stack allocated.</td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
a pointer to the first entry in the table or NULL if there are no entries.</dl><dl compact><dt><b>
See also: </b><dd>
<a class="el" href="ght__hash__table_8h.html#a15">ght_next</a>() </dl>    </td>
  </tr>
</table>
<a name="a12" doxytag="ght_hash_table.h::ght_get"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* ght_get </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>i_key_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p_key_data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lookup an entry in the hash table.
<p>
The entry is <em>not</em> removed from the table.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>p_ht</em>&nbsp;</td><td>
the hash table to search in. </td></tr>
<tr><td valign=top><em>i_key_size</em>&nbsp;</td><td>
the size of the key to search with (in bytes). </td></tr>
<tr><td valign=top><em>p_key_data</em>&nbsp;</td><td>
the key to search for.</td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
a pointer to the found entry or NULL if no entry could be found. </dl>    </td>
  </tr>
</table>
<a name="a11" doxytag="ght_hash_table.h::ght_insert"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int ght_insert </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p_entry_data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>i_key_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p_key_data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert an entry into the hash table.
<p>
Prior to inserting anything, make sure that the table is created with <a class="el" href="ght__hash__table_8h.html#a10">ght_create</a>(). If an element with the same key as this one already exists in the table, the insertion will fail and -1 is returned.
<p>
A typical example is shown below, where the string "blabla" is used as a key for the integer 15.
<p>
<pre>
 <a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_table;
 char *p_key_data;
 int *p_data;

 [Create p_table etc...]
 p_data = malloc(sizeof(int));
 p_key_data = "blabla";
 *p_data = 15;

 ght_insert(p_table,
            p_data,
            sizeof(char)*strlen(p_key_data), p_key_data);
 </pre><dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>p_ht</em>&nbsp;</td><td>
the hash table to insert into. </td></tr>
<tr><td valign=top><em>p_entry_data</em>&nbsp;</td><td>
the data to insert. </td></tr>
<tr><td valign=top><em>i_key_size</em>&nbsp;</td><td>
the size of the key to associate the data with (in bytes). </td></tr>
<tr><td valign=top><em>p_key_data</em>&nbsp;</td><td>
the key to use. The value will be copied, and it is therefore OK to use a stack-allocated entry here.</td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
0 if the element could be inserted, -1 otherwise. </dl>    </td>
  </tr>
</table>
<a name="a15" doxytag="ght_hash_table.h::ght_next"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* ght_next </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>ght_iterator_t *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p_iterator</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the next entry in the hash table.
<p>
This function should be used for iteration, and must be called after <a class="el" href="ght__hash__table_8h.html#a14">ght_first</a>().
<p>
<dl compact><dt><b>
Warning: </b><dd>
calling this without first having called ght_first will give undefined results (probably a crash), since p_iterator isn't filled correctly.</dl><dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>p_ht</em>&nbsp;</td><td>
the hash table to iterate through.</td></tr>
<tr><td valign=top><em>p_iterator</em>&nbsp;</td><td>
the iterator to use.</td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
a pointer to the next entry in the table or NULL if there are no more entries in the table.</dl><dl compact><dt><b>
See also: </b><dd>
<a class="el" href="ght__hash__table_8h.html#a14">ght_first</a>() </dl>    </td>
  </tr>
</table>
<a name="a18" doxytag="ght_hash_table.h::ght_one_at_a_time_hash"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="ght__hash__table_8h.html#a6">ght_uint32_t</a> ght_one_at_a_time_hash </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="ght__hash__table_8h.html#a7">ght_hash_key_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>p_key</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
One-at-a-time-hash.
<p>
One-at-a-time-hash is a good hash function, and is the default when <a class="el" href="ght__hash__table_8h.html#a10">ght_create</a>() is called with NULL as the fn_hash parameter. This was found in a DrDobbs article, see <a href="http://burtleburtle.net/bob/hash/doobs.html">http://burtleburtle.net/bob/hash/doobs.html</a>
<p>
<dl compact><dt><b>
Warning: </b><dd>
Don't call this function directly, it is only meant to be used as a callback for the hash table.</dl><dl compact><dt><b>
See also: </b><dd>
<a class="el" href="ght__hash__table_8h.html#a9">ght_fn_hash_t</a> , <a class="el" href="ght__hash__table_8h.html#a19">ght_rotating_hash</a>(), <a class="el" href="ght__hash__table_8h.html#a20">ght_crc_hash</a>() </dl>    </td>
  </tr>
</table>
<a name="a16" doxytag="ght_hash_table.h::ght_rehash"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ght_rehash </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>i_size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Rehash the hash table.
<p>
Rehashing will change the size of the hash table, retaining all elements. This is very costly and should be avoided unless really needed. If <code>GHT_AUTOMATIC_REHASH</code> is specified in the flag parameter when <a class="el" href="ght__hash__table_8h.html#a10">ght_create</a>() is called, the hash table is automatically rehashed when the number of stored elements exceeds two times the number of buckets in the table (making calls to this function unessessary).<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>p_ht</em>&nbsp;</td><td>
the hash table to rehash. </td></tr>
<tr><td valign=top><em>i_size</em>&nbsp;</td><td>
the new size of the table.</td></tr>
</table>
</dl><dl compact><dt><b>
See also: </b><dd>
<a class="el" href="ght__hash__table_8h.html#a10">ght_create</a>() </dl>    </td>
  </tr>
</table>
<a name="a13" doxytag="ght_hash_table.h::ght_remove"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* ght_remove </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>i_key_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p_key_data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove an entry from the hash table.
<p>
The entry is removed from the table, but not freed (that is, the data stored is not freed).<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>p_ht</em>&nbsp;</td><td>
the hash table to use. </td></tr>
<tr><td valign=top><em>i_key_size</em>&nbsp;</td><td>
the size of the key to search with (in bytes). </td></tr>
<tr><td valign=top><em>p_key_data</em>&nbsp;</td><td>
the key to search for.</td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
a pointer to the removed entry or NULL if the entry could be found. </dl>    </td>
  </tr>
</table>
<a name="a19" doxytag="ght_hash_table.h::ght_rotating_hash"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="ght__hash__table_8h.html#a6">ght_uint32_t</a> ght_rotating_hash </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="ght__hash__table_8h.html#a7">ght_hash_key_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>p_key</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Rotating hash.
<p>
Not so good hash function. This was found in a DrDobbs article, see <a href="http://burtleburtle.net/bob/hash/doobs.html">http://burtleburtle.net/bob/hash/doobs.html</a>
<p>
<dl compact><dt><b>
Warning: </b><dd>
Don't call this function directly, it is only meant to be used as a callback for the hash table.</dl><dl compact><dt><b>
See also: </b><dd>
<a class="el" href="ght__hash__table_8h.html#a9">ght_fn_hash_t</a> , <a class="el" href="ght__hash__table_8h.html#a18">ght_one_at_a_time_hash</a>(), <a class="el" href="ght__hash__table_8h.html#a20">ght_crc_hash</a>() </dl>    </td>
  </tr>
</table>
<hr><address><small>Generated on Sun Mar 24 13:07:43 2002 for libghthash by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.12 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
